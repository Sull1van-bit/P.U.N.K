<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>P.U.N.K - Life Simulation</title>
    <style>
        canvas {
            border: 3px solid red;
            display: block;
            margin: 0 auto;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
        }
        #statBar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 80px;
            background: linear-gradient(180deg, 
                #4a4a4a 0%,
                #3a3a3a 20%,
                #2a2a2a 50%,
                #3a3a3a 80%,
                #4a4a4a 100%
            );
            border-bottom: 2px solid #555;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            padding: 0 30px;
            box-sizing: border-box;
            z-index: 1000;
        }
        .stat-container {
            display: flex;
            align-items: center;
            margin-right: 30px;
            min-width: 200px;
        }
        .stat-container[style*="min-width: auto"] {
            min-width: 200px;
            margin-right: 0;
        }
        .stat-container[style*="min-width: auto"] .stat-value {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
            color: white;
            font-family: Arial, sans-serif;
            font-weight: bold;
            text-shadow: 2px 2px 2px rgba(0,0,0,0.7);
        }
        .stat-container[style*="min-width: auto"] .stat-bar-container {
            flex-grow: 1;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) inset;
        }
        .stat-icon {
            width: 40px;
            height: 40px;
            margin-right: 15px;
        }
        .stat-bar-container {
            flex-grow: 1;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) inset;
        }
        .stat-bar {
            height: 100%;
            width: 100%;
            transition: width 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }
        .stat-value {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            text-shadow: 2px 2px 2px rgba(0,0,0,0.7);
            font-weight: bold;
        }
        #hpBar { background-color: #ff4444; }
        #energyBar { background-color: #44ff44; }
        #hungerBar { background-color: #ffaa44; }
        #happinessBar { background-color: #44aaff; }
        #characterFrame {
            width: 65px;
            height: 65px;
            margin-right: 30px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }
        #characterFrame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #moneyBox {
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 15px;
            border-radius: 5px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: 20px;
        }
        #moneyBox img {
            width: 30px;
            height: 30px;
        }
        #moneyValue {
            color: #ffeb3b;
            font-family: Arial, sans-serif;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 2px rgba(0,0,0,0.7);
        }
        #optionOverlay {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #4a4a4a 0%, #2a2a2a 100%);
            padding: 20px;
            border: 2px solid #555;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            z-index: 2000;
        }
        .option-button {
            display: block;
            width: 200px;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(180deg, #666 0%, #444 100%);
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-align: center;
            transition: background 0.3s ease;
        }
        .option-button:hover {
            background: linear-gradient(180deg, #777 0%, #555 100%);
        }
        #timeDisplay {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 2px rgba(0,0,0,0.7);
            margin-left: auto; /* Push to the right */
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #timeDisplay::before {
            content: "ðŸ•’";
            font-size: 24px;
        }
        #codingGameOverlay {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #4a4a4a 0%, #2a2a2a 100%);
            padding: 30px;
            border: 2px solid #555;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            z-index: 2000;
            width: 600px;
            color: white;
            font-family: 'Courier New', monospace;
        }
        #codingGameOverlay h2 {
            text-align: center;
            margin-bottom: 10px;
            color: #44ff44;
            text-shadow: 0 0 10px rgba(68, 255, 68, 0.5);
        }
        #codingGameOverlay p {
            text-align: center;
            margin-bottom: 20px;
            color: #aaa;
            font-size: 14px;
        }
        .button-group {
            display: flex;
            gap: 10px;
        }
        .button-group button {
            flex: 1;
        }
        #codeDisplay {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 18px;
            line-height: 1.5;
            min-height: 100px;
            white-space: pre-wrap;
        }
        #codeInput {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #555;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            margin-bottom: 20px;
        }
        #codingGameOverlay button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(180deg, #666 0%, #444 100%);
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-align: center;
            transition: background 0.3s ease;
        }
        #codingGameOverlay button:hover {
            background: linear-gradient(180deg, #777 0%, #555 100%);
        }
        .correct {
            color: #44ff44;
        }
        .incorrect {
            color: #ff4444;
        }
        #foodShopOverlay {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #4a4a4a 0%, #2a2a2a 100%);
            padding: 30px;
            border: 2px solid #555;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            z-index: 2000;
            width: 400px;
            color: white;
            font-family: Arial, sans-serif;
        }
        #foodShopOverlay h2 {
            text-align: center;
            margin-bottom: 10px;
            color: #ff9800;
            text-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }
        .food-items {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        .food-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .food-item:hover {
            background: rgba(255, 152, 0, 0.1);
            border-color: #ff9800;
        }
        .food-item img {
            width: 40px;
            height: 40px;
            margin-bottom: 5px;
        }
        .food-item .price {
            color: #ffeb3b;
            font-weight: bold;
        }
        .food-item .hunger-boost {
            color: #ff9800;
            font-size: 0.9em;
        }
        #foodShopOverlay button.close-button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: linear-gradient(180deg, #666 0%, #444 100%);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }
        #foodShopOverlay button.close-button:hover {
            background: linear-gradient(180deg, #777 0%, #555 100%);
        }
        #tictactoeOverlay {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #4a4a4a 0%, #2a2a2a 100%);
            padding: 30px;
            border: 2px solid #555;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            z-index: 2000;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
        }
        #tictactoeOverlay h2 {
            color: #44aaff;
            text-shadow: 0 0 10px rgba(68, 170, 255, 0.5);
            margin-bottom: 20px;
        }
        .tictactoe-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px auto;
            width: 300px;
        }
        .tictactoe-cell {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #555;
            border-radius: 5px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .tictactoe-cell:hover {
            background: rgba(68, 170, 255, 0.1);
            border-color: #44aaff;
        }
        .tictactoe-cell.x {
            color: #ff4444;
        }
        .tictactoe-cell.o {
            color: #44aaff;
        }
        #gameStatus {
            margin: 20px 0;
            font-size: 18px;
            min-height: 27px;
        }
        #tictactoeOverlay button {
            padding: 10px 20px;
            margin: 5px;
            background: linear-gradient(180deg, #666 0%, #444 100%);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        #tictactoeOverlay button:hover {
            background: linear-gradient(180deg, #777 0%, #555 100%);
        }
    </style>
</head>
<body>
    <div id="statBar">
        <div id="characterFrame">
            <img id="characterIdle" src="" alt="Character">
        </div>
        <div class="stat-container">
            <img class="stat-icon" src="/P.U.N.K/asset/icon/hp.png" alt="HP">
            <div class="stat-bar-container">
                <div id="hpBar" class="stat-bar"></div>
                <span class="stat-value" id="hpValue">100%</span>
            </div>
        </div>
        <div class="stat-container">
            <img class="stat-icon" src="/P.U.N.K/asset/icon/energy.png" alt="Energy">
            <div class="stat-bar-container">
                <div id="energyBar" class="stat-bar"></div>
                <span class="stat-value" id="energyValue">100%</span>
            </div>
        </div>
        <div class="stat-container">
            <img class="stat-icon" src="/P.U.N.K/asset/icon/hunger.png" alt="Hunger">
            <div class="stat-bar-container">
                <div id="hungerBar" class="stat-bar"></div>
                <span class="stat-value" id="hungerValue">100%</span>
            </div>
        </div>
        <div class="stat-container">
            <img class="stat-icon" src="/P.U.N.K/asset/icon/happiness.png" alt="Happiness">
            <div class="stat-bar-container">
                <div id="happinessBar" class="stat-bar"></div>
                <span class="stat-value" id="happinessValue">100%</span>
            </div>
        </div>
        <div id="moneyBox">
            <img src="/P.U.N.K/asset/icon/money.png" alt="Money">
            <span id="moneyValue">$0</span>
        </div>
        <div id="timeDisplay">
            <span id="timeValue">00:00</span>
        </div>
    </div>

    <div id="optionOverlay">
        <button class="option-button" onclick="sleep()">Sleep</button>
        <button class="option-button" onclick="closeOverlay()">Cancel</button>
    </div>

    <div id="codingGameOverlay">
        <h2>Code Challenge</h2>
        <p>Type the code exactly as shown. Press Enter or click Submit when done.</p>
        <div id="codeDisplay"></div>
        <input type="text" id="codeInput" placeholder="Type the code here...">
        <div class="button-group">
            <button onclick="checkCode()">Submit</button>
            <button onclick="startCodingGame()">New Challenge</button>
            <button onclick="closeCodingGame()">Cancel</button>
        </div>
    </div>

    <div id="foodShopOverlay">
        <h2>Food Shop</h2>
        <div class="food-items">
            <div class="food-item" onclick="buyFood('Apple', 2, 15)">
                <img src="/P.U.N.K/asset/icon/apple.png" alt="Apple">
                <span>Apple</span>
                <span class="price">$2</span>
                <span class="hunger-boost">+15 Hunger</span>
            </div>
            <div class="food-item" onclick="buyFood('Bread', 3, 20)">
                <img src="/P.U.N.K/asset/icon/bread.png" alt="Bread">
                <span>Bread</span>
                <span class="price">$3</span>
                <span class="hunger-boost">+20 Hunger</span>
            </div>
            <div class="food-item" onclick="buyFood('Cheese', 5, 25)">
                <img src="/P.U.N.K/asset/icon/cheese.png" alt="Cheese">
                <span>Cheese</span>
                <span class="price">$5</span>
                <span class="hunger-boost">+25 Hunger</span>
            </div>
            <div class="food-item" onclick="buyFood('Steak', 10, 40)">
                <img src="/P.U.N.K/asset/icon/steak.png" alt="Steak">
                <span>Steak</span>
                <span class="price">$10</span>
                <span class="hunger-boost">+40 Hunger</span>
            </div>
        </div>
        <button class="close-button" onclick="closeFoodShop()">Close</button>
    </div>

    <div id="tictactoeOverlay">
        <h2>Tic-tac-toe Challenge</h2>
        <div id="gameStatus"></div>
        <div class="tictactoe-board" id="tictactoeBoard">
            <div class="tictactoe-cell" data-index="0"></div>
            <div class="tictactoe-cell" data-index="1"></div>
            <div class="tictactoe-cell" data-index="2"></div>
            <div class="tictactoe-cell" data-index="3"></div>
            <div class="tictactoe-cell" data-index="4"></div>
            <div class="tictactoe-cell" data-index="5"></div>
            <div class="tictactoe-cell" data-index="6"></div>
            <div class="tictactoe-cell" data-index="7"></div>
            <div class="tictactoe-cell" data-index="8"></div>
        </div>
        <button onclick="startNewGame()">New Game</button>
        <button onclick="closeTicTacToe()">Close</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <audio src="/P.U.N.K/asset/sound/Machinations - ContextSensitive.wav" loop autoplay></audio>

    <script>
        // Get selected character from localStorage
        const selectedCharacter = JSON.parse(localStorage.getItem('selectedCharacter'));
        console.log('Selected character:', selectedCharacter);
        
        // Stats initialization
        let stats = {
            hp: 100,
            energy: 100,
            hunger: 100,
            money: 0,
            happiness: 100
        };

        // Update stats display
        function updateStats() {
            console.log('Updating stats:', stats); // Debug log
            // Update text values
            document.getElementById('hpValue').textContent = stats.hp + '%';
            document.getElementById('energyValue').textContent = stats.energy + '%';
            document.getElementById('hungerValue').textContent = stats.hunger + '%';
            document.getElementById('moneyValue').textContent = '$' + stats.money;
            document.getElementById('happinessValue').textContent = stats.happiness + '%';

            // Update bar widths
            document.getElementById('hpBar').style.width = stats.hp + '%';
            document.getElementById('energyBar').style.width = stats.energy + '%';
            document.getElementById('hungerBar').style.width = stats.hunger + '%';
            document.getElementById('happinessBar').style.width = stats.happiness + '%';
        }

        // Set character idle animation
        const characterIdle = document.getElementById('characterIdle');
        characterIdle.src = `${selectedCharacter.directory}idle.gif`;

        // Stats update interval (every 5 seconds)
        setInterval(() => {
            // Decrease stats over time
            stats.energy = Math.max(0, stats.energy - 1);
            stats.hunger = Math.max(0, stats.hunger - 2);
            stats.happiness = Math.max(0, stats.happiness - 1);
            
            // Update HP based on other stats
            if (stats.energy < 20 || stats.hunger < 20) {
                stats.hp = Math.max(0, stats.hp - 1);
            }
            
            updateStats();
        }, 5000);

        // Initial stats update
        updateStats();
        
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size to window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Add these variables at the top of your script, after canvas setup
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            w: false,
            s: false,
            a: false,
            d: false
        };

        // Add after canvas setup
        const camera = {
            x: 0,
            y: 0,
            width: canvas.width,
            height: canvas.height,
            zoom: 2  // Increased zoom for larger map view
        };

        // Add map scale configuration
        const MAP_SCALE = 2; // Adjust this value to change map size

        // Add after camera setup
        const TILE_SIZE = 16; // Base tile size before scaling

        // Add collision map configuration
        const collisionMap = {
            tiles: [], // Will store collision data
            width: 0,
            height: 0
        };
        
        let currentScene = 'map'; // 'map' or 'room'
        let roomImage = new Image();
        roomImage.src = '/P.U.N.K/asset/Location/Kamar.png'; // Example room image

        const ROOM_POSITION = {
          x: 1, // Start at grid coordinate 13
          y: 10   // Start at grid coordinate 7
        };

        // Character class with fixed movement
        class Character {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.speed = 2.5;
                this.direction = 'down';
                this.frameCount = 0;
                this.animationSpeed = 2;
                this.isMoving = false;
                
                // Sprites setup
                this.sprites = {
                    up: [new Image(), new Image()],
                    down: [new Image(), new Image()],
                    left: [new Image(), new Image()],
                    right: [new Image(), new Image()]
                };

                // Load sprites and log for debugging
                Object.keys(this.sprites).forEach(direction => {
                    this.sprites[direction][0].src = `${selectedCharacter.directory}${direction}1.png`;
                    this.sprites[direction][1].src = `${selectedCharacter.directory}${direction}2.png`;
                    console.log(`Loading sprite: ${this.sprites[direction][0].src}`);
                });

                this.currentSprite = this.sprites.down[0];
            }

            draw() {
                if (this.isMoving) {
                    this.frameCount++;
                    const frameIndex = Math.floor(this.frameCount / this.animationSpeed) % 2;
                    this.currentSprite = this.sprites[this.direction][frameIndex];
                } else {
                    this.currentSprite = this.sprites[this.direction][0];
                    this.frameCount = 0;
                }

                ctx.drawImage(this.currentSprite, this.x, this.y, this.width, this.height);
            }

            move(dx, dy) {
                if (dx === 0 && dy === 0) {
                    this.isMoving = false;
                    return;
                }

                // Calculate next position
                const nextX = this.x + dx * this.speed;
                const nextY = this.y + dy * this.speed;

                // Check collision before moving
                if (!this.checkCollision(nextX, nextY)) {
                    this.x = nextX;
                    this.y = nextY;
                    this.isMoving = true;

                    // Update direction
                    if (dx < 0) this.direction = 'left';
                    else if (dx > 0) this.direction = 'right';
                    else if (dy < 0) this.direction = 'up';
                    else if (dy > 0) this.direction = 'down';
                }
            }

            checkCollision(nextX, nextY) {
                // Calculate the character's bounding box
                const charLeft = nextX;
                const charRight = nextX + this.width;
                const charTop = nextY;
                const charBottom = nextY + this.height;
                
                // Convert to tile coordinates
                const tileLeft = Math.floor(charLeft / (TILE_SIZE * MAP_SCALE));
                const tileRight = Math.floor((charRight - 1) / (TILE_SIZE * MAP_SCALE)); // Subtract 1 to avoid rounding up
                const tileTop = Math.floor(charTop / (TILE_SIZE * MAP_SCALE));
                const tileBottom = Math.floor((charBottom - 1) / (TILE_SIZE * MAP_SCALE)); // Subtract 1 to avoid rounding up
                
                // Check if character is outside map boundaries
                if (tileLeft < 0 || tileTop < 0 || 
                    tileRight >= collisionMap.width || 
                    tileBottom >= collisionMap.height) {
                    return true; // Collide with map boundaries
                }
                
                // Create a smaller hitbox for the character (80% of original size)
                // This creates a buffer zone allowing the character to squeeze through narrow passages
                const hitboxReduction = 0.2; // 20% reduction
                const hitboxLeft = nextX + (this.width * hitboxReduction / 2);
                const hitboxRight = nextX + this.width - (this.width * hitboxReduction / 2);
                const hitboxTop = nextY + (this.height * hitboxReduction / 2);
                const hitboxBottom = nextY + this.height - (this.height * hitboxReduction / 2);
                
                // Convert hitbox to tile coordinates
                const hitboxTileLeft = Math.floor(hitboxLeft / (TILE_SIZE * MAP_SCALE));
                const hitboxTileRight = Math.floor(hitboxRight / (TILE_SIZE * MAP_SCALE));
                const hitboxTileTop = Math.floor(hitboxTop / (TILE_SIZE * MAP_SCALE));
                const hitboxTileBottom = Math.floor(hitboxBottom / (TILE_SIZE * MAP_SCALE));
                
                // Check each tile the hitbox occupies
                for (let y = hitboxTileTop; y <= hitboxTileBottom; y++) {
                    for (let x = hitboxTileLeft; x <= hitboxTileRight; x++) {
                        if (collisionMap.tiles[y * collisionMap.width + x] === 1) {
                            return true; // Collision detected
                        }
                    }
                }
                
                return false; // No collision
            }
        }

        // Initialize game
        const mapImage = new Image();
        mapImage.src = '/P.U.N.K/asset/Location/map.png';

        let player; // Declare player variable

        // Start game when map is loaded
        mapImage.onload = () => {
            console.log('Map loaded successfully');
            console.log('Map dimensions:', mapImage.width, mapImage.height);
            
            // Initialize collision map dimensions
            collisionMap.width = Math.floor(mapImage.width / TILE_SIZE);
            collisionMap.height = Math.floor(mapImage.height / TILE_SIZE);
            console.log('Collision map dimensions:', collisionMap.width, collisionMap.height);
            
            // Create collision map (example - you'll need to customize this)
            createCollisionMap();
            
            // Create player after map is loaded
            player = new Character(
                13 * TILE_SIZE * MAP_SCALE, // X position: tile 13
                20 * TILE_SIZE * MAP_SCALE  // Y position: tile 20
            );
            
            console.log('Player spawned at:', player.x, player.y);
            
            // Add error handling for game loop
            try {
                requestAnimationFrame(gameLoop);
                console.log('Game loop started successfully');
            } catch (error) {
                console.error('Error starting game loop:', error);
            }
        };

        // Add collision map creation function
        function createCollisionMap() {
            // Initialize empty collision map
            const totalTiles = collisionMap.width * collisionMap.height;
            collisionMap.tiles = new Array(totalTiles).fill(0);

            // Example: Add some collision tiles (customize this based on your map)
            // 1 = solid/collision, 0 = walkable
            
            // Example: Adding border collision
            for (let x = 0; x < collisionMap.width; x++) {
                // Top and bottom borders
                collisionMap.tiles[x] = 1;
                collisionMap.tiles[(collisionMap.height - 1) * collisionMap.width + x] = 1;
            }
            for (let y = 0; y < collisionMap.height; y++) {
                // Left and right borders
                collisionMap.tiles[y * collisionMap.width] = 1;
                collisionMap.tiles[y * collisionMap.width + (collisionMap.width - 1)] = 1;
            }

            // Add new collision blocks at y=15, x=2 and x=3, and a row at y=2
            const collisionBlocks = [
                // Existing blocks
                { x: 2, y: 15, width: 1, height: 1 },
                { x: 3, y: 15, width: 1, height: 1 },
                // Row at y=2
                { x: 0, y: 2, width: collisionMap.width, height: 1 },
                // Row from x8 to x29 at y28
                { x: 8, y: 28, width: 22, height: 1 },
                // New vertical block at x11 from y5 to y17
                { x: 11, y: 5,  width: 1, height: 13 }, // height is 13 because 17 - 5 + 1 = 13 blocks
                { x: 5,  y: 17, width: 6, height: 1 }, // Added new block
                { x: 3, y: 17, width: 1, height: 1},
                { x: 6,  y: 5,  width: 6, height: 1},
                { x: 6,  y: 18, width: 3, height:1},
                { x: 15, y: 15, width: 9, height: 1},
                { x: 16, y: 14, width: 14, height: 1},
                { x: 21, y: 22, width: 1, height: 1},
                { x: 26, y: 22, width: 2, height: 2},
                { x: 25, y: 23, width: 1, height: 1},
                { x: 27, y: 15, width: 2, height: 4},
                { x: 4, y: 27, width: 1, height: 1},
                {x: 4, y: 16, width: 1, height: 1},
                { x: 6, y: 27, width: 2, height: 1},
                { x: 15, y: 27, width: 1, height: 1},
                { x: 18, y: 26, width: 1, height: 1},
                { x: 20, y: 27, width: 1, height: 1},
                { x: 25, y: 27, width: 1, height: 1},
                { x: 8, y: 26, width: 7, height: 1},
                { x: 9, y: 3, width: 2, height: 1},
                { x: 14, y: 3, width: 5, height: 1},
                { x: 21, y: 3, width: 1, height: 1},
                { x: 24, y: 6, width: 1, height: 1},
                { x: 27, y: 6, width: 1, height: 1},
                { x: 16, y: 7, width: 1, height: 1},
                { x: 19, y: 7, width: 1, height: 1},
                { x: 18, y: 10, width: 2, height: 1},
                { x: 16, y: 11, width: 13, height: 3},
                { x: 22, y: 8, width: 7, height: 3},
                { x: 16, y: 16, width: 6, height: 1},
                { x: 16, y: 17, width: 5, height: 1},
                { x: 24, y: 16, width: 1, height: 2},
                { x: 22, y: 17, width: 1, height: 1},
                { x: 25, y: 18, width: 1, height: 2},
                { x: 26, y: 19, width: 1, height: 1},
                { x: 15, y: 18, width: 1, height: 1},
                { x: 8, y: 25, width: 1, height: 1},
                { x: 14, y: 25, width: 1, height: 1},
                { x: 4, y: 23, width: 1, height: 1},
                { x: 6, y: 23, width: 1, height: 1},
                { x: 2, y: 24, width: 1, height: 1},
                { x: 3, y: 16, width: 1, height: 1},
                { x: 1, y: 15, width: 1, height: 1},
                
            ];

            // Add collision blocks to the map
            collisionBlocks.forEach(block => {
                for (let y = block.y; y < block.y + block.height; y++) {
                    for (let x = block.x; x < block.x + block.width; x++) {
                        collisionMap.tiles[y * collisionMap.width + x] = 1;
                    }
                }
            });

            // Add your custom collision areas here
            // Example: Adding a building
            const building = {
              x: 5,
              y: 3,
              width: 1,
              height: 15 // Added height property
            };

            for (let y = building.y; y < building.y + building.height; y++) {
                for (let x = building.x; x < building.x + building.width; x++) {
                    collisionMap.tiles[y * collisionMap.width + x] = 1;
                }
            }
        }

        // Add this to gameLoop for debugging collision map
        function drawCollisionMap() {
            // Draw grid
            ctx.globalAlpha = 0.2;
            ctx.strokeStyle = 'white';
            
            // Set text properties for grid coordinates
            ctx.font = '10px Arial';
            ctx.fillStyle = 'yellow';
            ctx.globalAlpha = 1;
            
            // Draw grid and coordinates
            for (let y = 0; y < collisionMap.height; y++) {
                for (let x = 0; x < collisionMap.width; x++) {
                    // Draw grid cell
                    ctx.strokeRect(
                        x * TILE_SIZE * MAP_SCALE,
                        y * TILE_SIZE * MAP_SCALE,
                        TILE_SIZE * MAP_SCALE,
                        TILE_SIZE * MAP_SCALE
                    );
                    
                    // Draw coordinates in each cell
                    ctx.fillText(
                        `${x},${y}`,
                        x * TILE_SIZE * MAP_SCALE + 2,
                        y * TILE_SIZE * MAP_SCALE + 12
                    );
                    
                    // Draw collision areas
                    if (collisionMap.tiles[y * collisionMap.width + x] === 1) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(
                            x * TILE_SIZE * MAP_SCALE,
                            y * TILE_SIZE * MAP_SCALE,
                            TILE_SIZE * MAP_SCALE,
                            TILE_SIZE * MAP_SCALE
                        );
                        ctx.fillStyle = 'yellow'; // Reset fill style for coordinates
                    }
                }
            }
            
            ctx.globalAlpha = 1;
        }

        // Event listeners
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
                e.preventDefault();
            }
        });

        function teleportToRoom() {
          // Change scene first
          currentScene = 'room';
          
          // Make sure roomImage is loaded
          if (!roomImage.complete) {
              console.log('Room image not loaded yet, waiting...');
              roomImage.onload = function() {
                  console.log('Room image loaded');
                  completeRoomSetup();
              };
          } else {
              completeRoomSetup();
          }
          function completeRoomSetup() {
              // Set player position WITHIN the room
              // Position the player at coordinates 8,22
              player.x = (8 * TILE_SIZE * MAP_SCALE);  
              player.y = (22 * TILE_SIZE * MAP_SCALE);
              
              // Create room collision map
              createRoomCollisionMap();
              
              console.log('Teleported to room at position:', player.x, player.y);
          }
       }

       function teleportToMap() {
            // Set coordinates for return position at 4,19
            player.x = 4 * TILE_SIZE * MAP_SCALE;
            player.y = 19 * TILE_SIZE * MAP_SCALE;
            
            // Change scene back to map
            currentScene = 'map';
            
            // Restore main map collision
            createCollisionMap();
            
            console.log('Teleported back to map at position 4,19');
        }

        function createRoomCollisionMap() {
            // Calculate room dimensions based on the image
            const roomWidthTiles = Math.ceil(roomImage.width / TILE_SIZE);
            const roomHeightTiles = Math.ceil(roomImage.height / TILE_SIZE);
            
            // Set collision map dimensions for the room
            collisionMap.width = 29; // Keep map size consistent 
            collisionMap.height = 29; // Keep map size consistent
            collisionMap.tiles = new Array(collisionMap.width * collisionMap.height).fill(0); // Clear all collision
            
            // Add walls around the room
            for (let x = ROOM_POSITION.x; x < ROOM_POSITION.x + 26; x++) {
                // Top and bottom walls
                if (x >= 0 && x < collisionMap.width) {
                    // Top wall
                    collisionMap.tiles[ROOM_POSITION.y * collisionMap.width + x] = 1;
                    // Bottom wall
                    collisionMap.tiles[(ROOM_POSITION.y + 29) * collisionMap.width + x] = 1;
                }
            }
            
            // Add side walls
            for (let y = ROOM_POSITION.y; y < ROOM_POSITION.y + 29; y++) {
                if (y >= 0 && y < collisionMap.height) {
                    // Left wall
                    collisionMap.tiles[y * collisionMap.width + ROOM_POSITION.x] = 1;
                    // Right wall
                    collisionMap.tiles[y * collisionMap.width + (ROOM_POSITION.x + 25)] = 1;
                }
            }
            
            // Add furniture collision
            const roomFurniture = [
                { x: 5, y: 7, width: 6, height: 5 },  // Existing furniture
                { x: 10, y: 5  , width: 2, height: 2 },  // Example of another piece
                { x: 5, y: 13, width: 19, height: 1},
                { x: 19, y: 12, width: 6, height: 1},
                { x: 11, y: 7, width: 18, height: 1},
                { x: 20, y: 8, width: 10, height: 1},
                { x: 4, y: 10, width: 1, height: 5},
            ];
            
            // Add furniture collision
            roomFurniture.forEach(furniture => {
                for (let y = 0; y < furniture.height; y++) {
                    for (let x = 0; x < furniture.width; x++) {
                        const mapX = ROOM_POSITION.x + furniture.x + x;
                        const mapY = ROOM_POSITION.y + furniture.y + y;
                        
                        if (mapX >= 0 && mapX < collisionMap.width && 
                            mapY >= 0 && mapY < collisionMap.height) {
                            collisionMap.tiles[mapY * collisionMap.width + mapX] = 1;
                            console.log(`Added collision at ${mapX},${mapY}`); // Debug log
                        }
                    }
                }
            });
            
            // Add door for exiting (mark it with value 2)
            const doorX = 6;  // Changed to x coordinate 6
            const doorY = 22; // Changed to y coordinate 22
            
            if (doorX >= 0 && doorX < collisionMap.width && 
                doorY >= 0 && doorY < collisionMap.height) {
                collisionMap.tiles[doorY * collisionMap.width + doorX] = 2; // Door = 2
            }
        }

        // Game initialization and loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            // Get current player tile position
            const playerTileX = Math.floor(player.x / (TILE_SIZE * MAP_SCALE));
            const playerTileY = Math.floor(player.y / (TILE_SIZE * MAP_SCALE));

            // Check for teleport triggers with a small range to make it more reliable
            if (currentScene === 'map' && 
                playerTileX === 4 && 
                playerTileY === 17) {
                teleportToRoom();
            }
            
            // Check if player is at door position in room (for exit)
            if (currentScene === 'room') {
                const tileIndex = playerTileY * collisionMap.width + playerTileX;
                if (collisionMap.tiles[tileIndex] === 2) { // 2 = door
                    teleportToMap();
                }
            }

            // Check for sleep option position in room
            if (currentScene === 'room' && 
                playerTileX === 13 && 
                playerTileY === 18) {
                showSleepOption();
            }

            // Check for computer position in room
            if (currentScene === 'room' && 
                playerTileX === 20 && 
                playerTileY === 18 &&
                !isCodingGameShowing) { // Only check if popup isn't showing
                showCodingGame();
            }

            // Check for food shop position in main map
            if (currentScene === 'map' && 
                playerTileX === 21 && 
                playerTileY === 17 &&
                !isFoodShopShowing) {
                showFoodShop();
            }

            // Check for Tic-tac-toe position in main map
            if (currentScene === 'map' && 
                playerTileX === 11 && 
                playerTileY === 17 &&
                !isTicTacToeShowing) {
                showTicTacToe();
            }

            // Calculate delta time
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update camera position to follow player
            camera.x = player.x - camera.width / (2 * camera.zoom);
            camera.y = player.y - camera.height / (2 * camera.zoom);
            
            // Save current context state
            ctx.save();
            
            // Apply camera transformations
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);
            
            // Draw current scene
            if (currentScene === 'map') {
                // Draw main map
                ctx.drawImage(
                    mapImage, 
                    0, 0, 
                    mapImage.width * MAP_SCALE, 
                    mapImage.height * MAP_SCALE
                );
            } else if (currentScene === 'room') {
                // Only draw room if the image is loaded
                if (roomImage.complete && roomImage.naturalWidth > 0) {
                    // Calculate room dimensions to match visible grid area
                    const roomWidth = 26 * TILE_SIZE * MAP_SCALE;  // Span from 13 to 27
                    const roomHeight = 29.8 * TILE_SIZE * MAP_SCALE;  // Make room taller
                    
                    ctx.drawImage(
                        roomImage,
                        ROOM_POSITION.x * TILE_SIZE * MAP_SCALE,
                        ROOM_POSITION.y * TILE_SIZE * MAP_SCALE,
                        roomWidth,  // Use calculated width
                        roomHeight  // Use calculated height
                    );
                } else {
                    // If room image isn't loaded, draw a placeholder
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(
                        ROOM_POSITION.x * TILE_SIZE * MAP_SCALE,
                        ROOM_POSITION.y * TILE_SIZE * MAP_SCALE,
                        15 * TILE_SIZE * MAP_SCALE,  // Match room width
                        12 * TILE_SIZE * MAP_SCALE   // Match room height
                    );
                    ctx.fillStyle = 'white';
                    ctx.font = '20px Arial';
                    ctx.fillText('Loading room...', 
                        ROOM_POSITION.x * TILE_SIZE * MAP_SCALE + 20, 
                        ROOM_POSITION.y * TILE_SIZE * MAP_SCALE + 40
                    );
                }
            }
            
            // Draw collision map for debugging
            
            // Draw player
            player.draw();
            
            // Restore context state
            ctx.restore();

            // Handle movement
            let dx = 0;
            let dy = 0;
            
            // Arrow keys and WASD
            if (keys.ArrowLeft || keys.a) dx -= 1;
            if (keys.ArrowRight || keys.d) dx += 1;
            if (keys.ArrowUp || keys.w) dy -= 1;
            if (keys.ArrowDown || keys.s) dy += 1;
            
            // Update player
            player.move(dx, dy);

            requestAnimationFrame(gameLoop);
        }

        // Add these new functions
        function showSleepOption() {
            document.getElementById('optionOverlay').style.display = 'block';
        }

        function closeOverlay() {
            document.getElementById('optionOverlay').style.display = 'none';
        }

        // Add time system
        const gameTime = {
            hours: 8,
            minutes: 0,
            daysPassed: 0,
            
            addMinutes: function(minutes) {
                this.minutes += minutes;
                while (this.minutes >= 60) {
                    this.minutes -= 60;
                    this.hours++;
                }
                while (this.hours >= 24) {
                    this.hours -= 24;
                    this.daysPassed++;
                }
                this.updateDisplay();
            },
            
            updateDisplay: function() {
                const hoursStr = this.hours.toString().padStart(2, '0');
                const minutesStr = this.minutes.toString().padStart(2, '0');
                document.getElementById('timeValue').textContent = `${hoursStr}:${minutesStr}`;
            }
        };

        // Update time every 5 seconds (same as stats update)
        setInterval(() => {
            gameTime.addMinutes(10); // Add 10 minutes every 5 seconds
        }, 5000);

        // Initialize time display
        gameTime.updateDisplay();

        // Modify sleep function to advance time
        function sleep() {
            // Advance time by 8 hours
            gameTime.addMinutes(480);
            
            // Restore energy and health
            stats.energy = 100;
            stats.hp = Math.min(stats.hp + 30, 100);
            updateStats();
            
            // Close the overlay
            closeOverlay();
        }

        // Add coding game variables
        let currentCode = '';
        let codeInput = '';
        let isCodingGameActive = false;
        let isCodingGameShowing = false; // Add flag to track if popup is showing

        // Add coding game functions
        function showCodingGame() {
            if (!isCodingGameShowing) { // Only show if not already showing
                document.getElementById('codingGameOverlay').style.display = 'block';
                startCodingGame();
                isCodingGameShowing = true;
            }
        }

        function closeCodingGame() {
            document.getElementById('codingGameOverlay').style.display = 'none';
            isCodingGameActive = false;
            isCodingGameShowing = false; // Reset flag when closing
        }

        function generateRandomCode() {
            const codeSnippets = [
                'function calculateSum(a, b) {\n  return a + b;\n}',
                'const numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((a, b) => a + b);',
                'class Person {\n  constructor(name) {\n    this.name = name;\n  }\n}',
                'const fetchData = async () => {\n  const response = await fetch(url);\n  return response.json();\n}',
                'const map = new Map();\nmap.set("key", "value");\nconsole.log(map.get("key"));'
            ];
            return codeSnippets[Math.floor(Math.random() * codeSnippets.length)];
        }

        function startCodingGame() {
            currentCode = generateRandomCode();
            codeInput = '';
            isCodingGameActive = true;
            document.getElementById('codeDisplay').textContent = currentCode;
            document.getElementById('codeInput').value = '';
            document.getElementById('codeInput').focus();
        }

        function checkCode() {
            if (!isCodingGameActive) return;

            const input = document.getElementById('codeInput').value;
            const display = document.getElementById('codeDisplay');
            
            // Normalize both strings by removing extra whitespace
            const normalizedInput = input.replace(/\s+/g, ' ').trim();
            const normalizedCode = currentCode.replace(/\s+/g, ' ').trim();
            
            if (normalizedInput === normalizedCode) {
                // Player won
                stats.money += 15;
                console.log('Money before update:', stats.money); // Debug log
                gameTime.addMinutes(480); // Add 8 hours
                updateStats();
                console.log('Money after update:', stats.money); // Debug log
                closeCodingGame();
            } else {
                // Show error message
                display.innerHTML = `<span style="color: #ff4444">Incorrect! Try again or start a new challenge.</span><br><br>${currentCode}`;
            }
        }

        // Add event listener for code input
        document.getElementById('codeInput').addEventListener('input', function(e) {
            if (!isCodingGameActive) return;
            
            const input = e.target.value;
            const display = document.getElementById('codeDisplay');
            let html = '';
            
            for (let i = 0; i < currentCode.length; i++) {
                if (i < input.length) {
                    if (input[i] === currentCode[i]) {
                        html += `<span class="correct">${currentCode[i]}</span>`;
                    } else {
                        html += `<span class="incorrect">${currentCode[i]}</span>`;
                    }
                } else {
                    html += currentCode[i];
                }
            }
            
            display.innerHTML = html;
        });

        // Add event listener for Enter key
        document.getElementById('codeInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent form submission
                checkCode();
            }
        });

        // Add food shop variables and functions
        let isFoodShopShowing = false;

        function showFoodShop() {
            if (!isFoodShopShowing) {
                document.getElementById('foodShopOverlay').style.display = 'block';
                isFoodShopShowing = true;
            }
        }

        function closeFoodShop() {
            document.getElementById('foodShopOverlay').style.display = 'none';
            isFoodShopShowing = false;
        }

        function buyFood(name, price, hungerBoost) {
            if (stats.money >= price) {
                stats.money -= price;
                stats.hunger = Math.min(100, stats.hunger + hungerBoost);
                updateStats();
                alert(`Bought ${name}! Hunger +${hungerBoost}`);
            } else {
                alert("Not enough money!");
            }
        }

        // Add Tic-tac-toe variables and functions
        let isTicTacToeShowing = false;
        let currentBoard = Array(9).fill('');
        let isPlayerTurn = true;
        let gameEnded = false;

        function showTicTacToe() {
            if (!isTicTacToeShowing) {
                document.getElementById('tictactoeOverlay').style.display = 'block';
                isTicTacToeShowing = true;
                startNewGame();
            }
        }

        function closeTicTacToe() {
            document.getElementById('tictactoeOverlay').style.display = 'none';
            isTicTacToeShowing = false;
        }

        function startNewGame() {
            currentBoard = Array(9).fill('');
            isPlayerTurn = true;
            gameEnded = false;
            updateBoard();
            document.getElementById('gameStatus').textContent = "Your turn! (X)";
        }

        function updateBoard() {
            const cells = document.getElementsByClassName('tictactoe-cell');
            for (let i = 0; i < cells.length; i++) {
                cells[i].textContent = currentBoard[i];
                cells[i].className = 'tictactoe-cell' + (currentBoard[i] ? ' ' + currentBoard[i].toLowerCase() : '');
            }
        }

        function checkWinner() {
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6] // Diagonals
            ];

            for (let pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (currentBoard[a] && currentBoard[a] === currentBoard[b] && currentBoard[a] === currentBoard[c]) {
                    return currentBoard[a];
                }
            }

            if (currentBoard.every(cell => cell !== '')) {
                return 'tie';
            }

            return null;
        }

        function makeAIMove() {
            // Simple AI: Look for winning move, then blocking move, then center, then random
            const emptyCells = currentBoard.reduce((acc, cell, index) => {
                if (!cell) acc.push(index);
                return acc;
            }, []);

            // Try to win
            for (let index of emptyCells) {
                currentBoard[index] = 'O';
                if (checkWinner() === 'O') {
                    return;
                }
                currentBoard[index] = '';
            }

            // Try to block
            for (let index of emptyCells) {
                currentBoard[index] = 'X';
                if (checkWinner() === 'X') {
                    currentBoard[index] = 'O';
                    return;
                }
                currentBoard[index] = '';
            }

            // Take center if available
            if (!currentBoard[4]) {
                currentBoard[4] = 'O';
                return;
            }

            // Take random empty cell
            const randomIndex = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            currentBoard[randomIndex] = 'O';
        }

        function handleCellClick(index) {
            if (!isPlayerTurn || gameEnded || currentBoard[index]) return;

            // Player's move
            currentBoard[index] = 'X';
            updateBoard();

            let winner = checkWinner();
            if (winner) {
                handleGameEnd(winner);
                return;
            }

            // AI's move
            isPlayerTurn = false;
            document.getElementById('gameStatus').textContent = "AI is thinking...";
            
            setTimeout(() => {
                makeAIMove();
                updateBoard();
                
                winner = checkWinner();
                if (winner) {
                    handleGameEnd(winner);
                    return;
                }

                isPlayerTurn = true;
                document.getElementById('gameStatus').textContent = "Your turn! (X)";
            }, 500);
        }

        function handleGameEnd(winner) {
            gameEnded = true;
            let message = '';
            if (winner === 'X') {
                message = "You won! Happiness increased!";
                stats.happiness = Math.min(100, stats.happiness + 15);
            } else if (winner === 'O') {
                message = "You lost! Happiness decreased...";
                stats.happiness = Math.max(0, stats.happiness - 10);
            } else {
                message = "It's a tie!";
                stats.happiness = Math.min(100, stats.happiness + 5);
            }
            document.getElementById('gameStatus').textContent = message;
            updateStats();
        }

        // Add event listeners for the Tic-tac-toe cells
        document.addEventListener('DOMContentLoaded', function() {
            const cells = document.getElementsByClassName('tictactoe-cell');
            for (let i = 0; i < cells.length; i++) {
                cells[i].addEventListener('click', function() {
                    handleCellClick(parseInt(this.getAttribute('data-index')));
                });
            }
        });
    </script>
</body>
</html>